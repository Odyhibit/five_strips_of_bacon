<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bacon Cipher Encoder/Decoder</title>
</head>
<body>
    <h2>Bacon Cipher Encoder/Decoder</h2>
    <label for="hiddenText">Hidden Text:</label>
    <input type="text" id="hiddenText" placeholder="Enter hidden text">
    <br>
    <label for="coverText">Cover Text:</label>
    <input type="text" id="coverText" placeholder="Enter cover text">
    <br>
    <label for="format">Select Format:</label>
    <select id="format">
        <option value="Unicode">Unicode</option>
        <option value="Discord">Discord</option>
        <option value="GitHub">GitHub</option>
    </select>
    <br>
    <button onclick="encodeText()">Encode</button>
    <button onclick="decodeText()">Decode</button>
    <h3>Result:</h3>
    <p id="result"></p>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans', sans-serif;
        }
        </style>
    <script>
        const baconDictionary = {
            "a": "00000", "b": "00001", "c": "00010", "d": "00011", "e": "00100",
            "f": "00101", "g": "00110", "h": "00111", "i": "01000", "j": "01000",
            "k": "01001", "l": "01010", "m": "01011", "n": "01100", "o": "01101",
            "p": "01110", "q": "01111", "r": "10000", "s": "10001", "t": "10010",
            "u": "10011", "v": "10011", "w": "10100", "x": "10101", "y": "10110", "z": "10111"
        };

        const reverseBaconDictionary = Object.fromEntries(
            Object.entries(baconDictionary).map(([key, value]) => [value, key])
        );

        function getBitMask(hiddenText) {
            return hiddenText.toLowerCase().split('').map(char => baconDictionary[char] || '').join('');
        }

        function hasCodepoint(str, codePoint) {
          let count = 0;
          for (const char of str) {

            if (char.codePointAt(count) === codePoint) {
              return true;
            }
            count++;
          }
          return false;
        }

        function isInRange(number, min, max) {
            return number >= min && number <= max;
        }

        function encodeText() {
            const hiddenText = document.getElementById("hiddenText").value;
            const coverText = document.getElementById("coverText").value;
            const format = document.getElementById("format").value;
            const secretBinStr = getBitMask(hiddenText);
            let output = "";
            let binIndex = 0;

            for (let i = 0; i < coverText.length; i++) {
                if (binIndex < secretBinStr.length / 5) {
                    if (/[a-zA-Z]/.test(coverText[i])) {
                        output += modifyLetter(coverText[i], secretBinStr.substring(binIndex * 5, binIndex * 5 + 5), format);
                        console.log(output);
                        binIndex++;
                    } else {
                        output += coverText[i];
                    }
                } else {
                    output += coverText[i];
                }
            }
            document.getElementById("result").innerText = output;
        }

        function modifyLetter(letter, bitMask, format) {
            let zeroWidthSpace = "\u200B";
            let modifiedLetter = letter;


            if (format === "Unicode" && /[a-zA-Z]/.test(letter)) {
                const letterOffset = letter.toUpperCase().charCodeAt(0) - 65;
                console.log(bitMask, letterOffset,parseInt('0x1d400', 16) + letterOffset);
                console.log(String.fromCodePoint(parseInt('0x1d41a', 16) + letterOffset));
                //Bold,uppercase
                if (bitMask[0] === "1" && bitMask[3] === "1") modifiedLetter = String.fromCodePoint(parseInt('0x1d400', 16) + letterOffset);
                //Bold, lowercase
                else if (bitMask[0] === "1" && bitMask[3] !== "1") modifiedLetter = String.fromCodePoint(parseInt('0x1d41a', 16) + letterOffset);
                // italic, uppercase
                else if (bitMask[1] === "1" && bitMask[3] === "1") modifiedLetter = String.fromCodePoint(parseInt('0x1D434', 16) + letterOffset);
                //italic, lowercase
                else if (bitMask[1] === "1" && bitMask[3] !== "1") modifiedLetter = String.fromCodePoint(parseInt('0x1d44e', 16)  + letterOffset);
                                if (letterOffset == 7){
                                    this_letter = String.fromCodePoint(parseInt(0x210e, 16));  // glyph is reserved, so use plank's constant
                                }
                //regular uppercase
                if (bitMask.substring(0, 2) === "00" && bitMask[3] === "1") modifiedLetter = letter.toUpperCase();
                // strikethrough
                if (bitMask[2] === "1") modifiedLetter += "\u0336";
                // underline
                if (bitMask[4] === "1") modifiedLetter += "\u0332";
            }
            console.log(modifiedLetter, zeroWidthSpace);
            return modifiedLetter + zeroWidthSpace;
        }



        function decodeText() {
            const coverText = document.getElementById("coverText").value;
            let output = "";
            const letters = coverText.split("\u200B");
            console.log("there are ", letters.length, "letters");

            for (const char of letters) {
                console.log("the letter is", char);
                let bitMask = decodeLetter(char);
                output += reverseBaconDictionary[bitMask] || "?";


            }

            for (const char of letters) {
                const codePoint = char.codePointAt(0);
                console.log(`Character: ${char}, Code Point: ${codePoint}`);
            }

            document.getElementById("result").innerText = output;
        }

        function decodeLetter(letter) {
            // Bold, Itallic, Strikethrough, Capital, Underline
            // Bold 0x1D400 - 0x1D433
            // Itallic 0x1D434 - 0x1D467
            // Strikethrough \u0336
            // Capital 0x1D400-0x1D419 ||  0x1D434-1D44D || 0x41-0x5A
            // Underline \u0332

            let strikethrough = "\u0336";
            let underline = "\u0332";
            console.log(letter);
            let output = [0, 0, 0, 0, 0];
            let firstCodePoint = letter.codePointAt(0);

            if (isInRange(firstCodePoint, 0x1D400, 0x1D433)) output[0] = 1;  // Bold
            if (isInRange(firstCodePoint, 0x1D434, 0x1D467)) output[1] = 1;  // Itallic
            if (hasCodepoint(letter,strikethrough)) output[2] = 1;    // Strikethrough
            if (isInRange(firstCodePoint, 0x1D400, 0x1D419) || isInRange(firstCodePoint, 0x1D434, 0x1D44D) || isInRange(firstCodePoint, 0x41, 0x5A)) output[3] = 1;    // Strikethrough
            if (hasCodepoint(letter,underline)) output[4] = 1;
            console.log(output.join(""))
            return output.join("");
        }
    </script>
</body>
</html>
